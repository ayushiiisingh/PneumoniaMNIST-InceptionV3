# -*- coding: utf-8 -*-
"""pneumonia_detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IE0AzC5pRfIqLtRzKw9z8QcgFUUBbmBN
"""

import numpy as np
import tensorflow as tf
from tensorflow.keras.applications import InceptionV3
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D, Dropout
from tensorflow.keras.models import Model
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import classification_report, roc_auc_score, f1_score
from sklearn.utils import class_weight

# ---- Load Dataset (.npz) ----
data = np.load('/content/pneumoniamnist.npz')
x_train, y_train = data['train_images'], data['train_labels'].flatten()
x_val, y_val = data['val_images'], data['val_labels'].flatten()
x_test, y_test = data['test_images'], data['test_labels'].flatten()

# ---- Preprocess ----
def preprocess(x):
    x = x.astype('float32') / 255.0
    if x.ndim == 3:  # shape: (N, 28, 28)
        x = np.expand_dims(x, -1)         # → (N, 28, 28, 1)
    x = np.repeat(x, 3, axis=-1)          # → (N, 28, 28, 3)
    x = tf.image.resize(x, [75, 75]).numpy()  # Resize for InceptionV3
    return x

x_train = preprocess(x_train)
x_val = preprocess(x_val)
x_test = preprocess(x_test)

# ---- Build Model ----
base = InceptionV3(weights='imagenet', include_top=False, input_shape=(75, 75, 3))
x = GlobalAveragePooling2D()(base.output)
x = Dropout(0.5)(x)
x = Dense(128, activation='relu')(x)
out = Dense(1, activation='sigmoid')(x)
model = Model(inputs=base.input, outputs=out)

# Unfreeze top 50 layers
for layer in base.layers[:-50]:
    layer.trainable = False
for layer in base.layers[-50:]:
    layer.trainable = True

# ---- Augmentation ----
datagen = ImageDataGenerator(
    rotation_range=10,
    width_shift_range=0.1,
    height_shift_range=0.1,
    zoom_range=0.1,
    horizontal_flip=True
)
datagen.fit(x_train)

# ---- Compile & Train ----
model.compile(optimizer=tf.keras.optimizers.Adam(1e-4),
              loss='binary_crossentropy',
              metrics=['accuracy'])

# Optional: use class weights to address imbalance
cw = class_weight.compute_class_weight('balanced', classes=np.unique(y_train), y=y_train)
cw_dict = {0: cw[0], 1: cw[1]}

history = model.fit(datagen.flow(x_train, y_train, batch_size=32),
                    validation_data=(x_val, y_val),
                    epochs=20,
                    class_weight=cw_dict)

# ---- Evaluate ----
y_pred = (model.predict(x_test) > 0.5).astype(int).flatten()
print(classification_report(y_test, y_pred))
print("ROC-AUC:", roc_auc_score(y_test, y_pred))
print("F1 Score:", f1_score(y_test, y_pred))

import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, roc_curve, auc, classification_report, precision_recall_fscore_support
import numpy as np

# Get predicted probabilities
y_prob = model.predict(x_test).flatten()
y_pred = (y_prob > 0.5).astype(int)

# ---------- 1. Confusion Matrix ----------
cm = confusion_matrix(y_test, y_pred)
fig, ax = plt.subplots()
ax.matshow(cm, cmap=plt.cm.Blues)
for i in range(2):
    for j in range(2):
        ax.text(j, i, cm[i, j], va='center', ha='center')
plt.title('Confusion Matrix')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.xticks([0, 1], ['Normal', 'Pneumonia'])
plt.yticks([0, 1], ['Normal', 'Pneumonia'])
plt.tight_layout()
plt.show()

# ---------- 2. ROC Curve ----------
fpr, tpr, _ = roc_curve(y_test, y_prob)
roc_auc = auc(fpr, tpr)

plt.figure()
plt.plot(fpr, tpr, label='ROC curve (AUC = {:.3f})'.format(roc_auc), color='darkred')
plt.plot([0, 1], [0, 1], linestyle='--', color='gray')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# ---------- 3. Bar Chart: Precision, Recall, F1 ----------
precision, recall, f1, _ = precision_recall_fscore_support(y_test, y_pred)
labels = ['Normal', 'Pneumonia']

x = np.arange(len(labels))
bar_width = 0.25

plt.figure(figsize=(7, 4))
plt.bar(x, precision, width=bar_width, label='Precision')
plt.bar(x + bar_width, recall, width=bar_width, label='Recall')
plt.bar(x + 2*bar_width, f1, width=bar_width, label='F1 Score')

plt.xticks(x + bar_width, labels)
plt.ylim(0, 1.05)
plt.ylabel('Score')
plt.title('Precision, Recall, F1-Score by Class')
plt.legend()
plt.tight_layout()
plt.show()